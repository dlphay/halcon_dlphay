///////////////////////////////////////////////////////////////////////////////
//  File generated by HDevelop for HALCON/C++ Version 12.0
///////////////////////////////////////////////////////////////////////////////



#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#  if defined(__linux__) && !defined(NO_EXPORT_APP_MAIN)
#    include <X11/Xlib.h>
#  endif
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#  include <stdio.h>
#  include <HALCON/HpThread.h>
#  include <CoreFoundation/CFRunLoop.h>
#endif



using namespace HalconCpp;

// Procedure declarations 
// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, HTuple hv_Bold, 
    HTuple hv_Slant);
// Chapter: Graphics / Text
// Short Description: This procedure displays 'Click 'Run' to continue' in the lower right corner of the screen. 
void disp_continue_message (HTuple hv_WindowHandle, HTuple hv_Color, HTuple hv_Box);
// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_message (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
    HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box);
// Local procedures 
void dev_display_profile_line (HTuple hv_Row, HTuple hv_Col, HTuple hv_Phi, HTuple hv_Length1, 
    HTuple hv_Length2);
void dev_display_measure_object (HTuple hv_Row, HTuple hv_Col, HTuple hv_Phi, HTuple hv_Length1, 
    HTuple hv_Length2);
void dev_display_profile_points (HTuple hv_PRows, HTuple hv_PCols, HTuple hv_Row, 
    HTuple hv_Col, HTuple hv_Phi, HTuple hv_Length1, HTuple hv_Length2);
// Short Description: Displays text right of the center of two given points. 
void p_disp_text_right_of_center (HTuple hv_WindowHandle, HTuple hv_Text, HTuple hv_RowFirst, 
    HTuple hv_ColFirst, HTuple hv_RowSecond, HTuple hv_ColSecond, HTuple hv_Phi, 
    HTuple hv_Distance);
// Short Description: Displays a marker, which indicates the position of an edge 
void p_disp_edge_marker (HTuple hv_Row, HTuple hv_Col, HTuple hv_Phi, HTuple hv_Length, 
    HTuple hv_Color, HTuple hv_LineWidth, HTuple hv_WindowHandle);
// Short Description: Displays text right of the center of two given points. 
void p_disp_text_left_of_center (HTuple hv_WindowHandle, HTuple hv_Text, HTuple hv_RowFirst, 
    HTuple hv_ColFirst, HTuple hv_RowSecond, HTuple hv_ColSecond, HTuple hv_Phi, 
    HTuple hv_Distance);
// Short Description: Displays the dimension of the measured edge pairs. 
void p_disp_dimensions (HTuple hv_RowEdgeFirst, HTuple hv_ColumnEdgeFirst, HTuple hv_RowEdgeSecond, 
    HTuple hv_ColumnEdgeSecond, HTuple hv_IntraDistance, HTuple hv_InterDistance, 
    HTuple hv_Phi, HTuple hv_Length, HTuple hv_WindowHandle);
void get_tmp_dir (HTuple *hv_LocalTemp);
void gen_initial_trainfile (HTuple hv_TrainFileName);

// Procedures 
// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, HTuple hv_Bold, 
    HTuple hv_Slant)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_OS, hv_BufferWindowHandle, hv_Ascent;
  HTuple  hv_Descent, hv_Width, hv_Height, hv_Scale, hv_Exception;
  HTuple  hv_SubFamily, hv_Fonts, hv_SystemFonts, hv_Guess;
  HTuple  hv_I, hv_Index, hv_AllowedFontSizes, hv_Distances;
  HTuple  hv_Indices, hv_FontSelRegexp, hv_FontsCourier;

  //This procedure sets the text font of the current window with
  //the specified attributes.
  //It is assumed that following fonts are installed on the system:
  //Windows: Courier New, Arial Times New Roman
  //Mac OS X: CourierNewPS, Arial, TimesNewRomanPS
  //Linux: courier, helvetica, times
  //Because fonts are displayed smaller on Linux than on Windows,
  //a scaling factor of 1.25 is used the get comparable results.
  //For Linux, only a limited number of font sizes is supported,
  //to get comparable results, it is recommended to use one of the
  //following sizes: 9, 11, 14, 16, 20, 27
  //(which will be mapped internally on Linux systems to 11, 14, 17, 20, 25, 34)
  //
  //Input parameters:
  //WindowHandle: The graphics window for which the font will be set
  //Size: The font size. If Size=-1, the default of 16 is used.
  //Bold: If set to 'true', a bold font is used
  //Slant: If set to 'true', a slanted font is used
  //
  GetSystem("operating_system", &hv_OS);
  // dev_get_preferences(...); only in hdevelop
  // dev_set_preferences(...); only in hdevelop
  if (0 != (HTuple(hv_Size==HTuple()).TupleOr(hv_Size==-1)))
  {
    hv_Size = 16;
  }
  if (0 != ((hv_OS.TupleSubstr(0,2))==HTuple("Win")))
  {
    //Set font on Windows systems
    try
    {
      //Check, if font scaling is switched on
      OpenWindow(0, 0, 256, 256, 0, "buffer", "", &hv_BufferWindowHandle);
      SetFont(hv_BufferWindowHandle, "-Consolas-16-*-0-*-*-1-");
      GetStringExtents(hv_BufferWindowHandle, "test_string", &hv_Ascent, &hv_Descent, 
          &hv_Width, &hv_Height);
      //Expected width is 110
      hv_Scale = 110.0/hv_Width;
      hv_Size = (hv_Size*hv_Scale).TupleInt();
      CloseWindow(hv_BufferWindowHandle);
    }
    // catch (Exception) 
    catch (HalconCpp::HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      //throw (Exception)
    }
    if (0 != (HTuple(hv_Font==HTuple("Courier")).TupleOr(hv_Font==HTuple("courier"))))
    {
      hv_Font = "Courier New";
    }
    else if (0 != (hv_Font==HTuple("mono")))
    {
      hv_Font = "Consolas";
    }
    else if (0 != (hv_Font==HTuple("sans")))
    {
      hv_Font = "Arial";
    }
    else if (0 != (hv_Font==HTuple("serif")))
    {
      hv_Font = "Times New Roman";
    }
    if (0 != (hv_Bold==HTuple("true")))
    {
      hv_Bold = 1;
    }
    else if (0 != (hv_Bold==HTuple("false")))
    {
      hv_Bold = 0;
    }
    else
    {
      hv_Exception = "Wrong value of control parameter Bold";
      throw HalconCpp::HException(hv_Exception);
    }
    if (0 != (hv_Slant==HTuple("true")))
    {
      hv_Slant = 1;
    }
    else if (0 != (hv_Slant==HTuple("false")))
    {
      hv_Slant = 0;
    }
    else
    {
      hv_Exception = "Wrong value of control parameter Slant";
      throw HalconCpp::HException(hv_Exception);
    }
    try
    {
      SetFont(hv_WindowHandle, ((((((("-"+hv_Font)+"-")+hv_Size)+"-*-")+hv_Slant)+"-*-*-")+hv_Bold)+"-");
    }
    // catch (Exception) 
    catch (HalconCpp::HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      //throw (Exception)
    }
  }
  else if (0 != ((hv_OS.TupleSubstr(0,2))==HTuple("Dar")))
  {
    //Set font on Mac OS X systems. Since OS X does not have a strict naming
    //scheme for font attributes, we use tables to determine the correct font
    //name.
    hv_SubFamily = 0;
    if (0 != (hv_Slant==HTuple("true")))
    {
      hv_SubFamily = hv_SubFamily|1;
    }
    else if (0 != (hv_Slant!=HTuple("false")))
    {
      hv_Exception = "Wrong value of control parameter Slant";
      throw HalconCpp::HException(hv_Exception);
    }
    if (0 != (hv_Bold==HTuple("true")))
    {
      hv_SubFamily = hv_SubFamily|2;
    }
    else if (0 != (hv_Bold!=HTuple("false")))
    {
      hv_Exception = "Wrong value of control parameter Bold";
      throw HalconCpp::HException(hv_Exception);
    }
    if (0 != (hv_Font==HTuple("mono")))
    {
      hv_Fonts.Clear();
      hv_Fonts[0] = "Menlo-Regular";
      hv_Fonts[1] = "Menlo-Italic";
      hv_Fonts[2] = "Menlo-Bold";
      hv_Fonts[3] = "Menlo-BoldItalic";
    }
    else if (0 != (HTuple(hv_Font==HTuple("Courier")).TupleOr(hv_Font==HTuple("courier"))))
    {
      hv_Fonts.Clear();
      hv_Fonts[0] = "CourierNewPSMT";
      hv_Fonts[1] = "CourierNewPS-ItalicMT";
      hv_Fonts[2] = "CourierNewPS-BoldMT";
      hv_Fonts[3] = "CourierNewPS-BoldItalicMT";
    }
    else if (0 != (hv_Font==HTuple("sans")))
    {
      hv_Fonts.Clear();
      hv_Fonts[0] = "ArialMT";
      hv_Fonts[1] = "Arial-ItalicMT";
      hv_Fonts[2] = "Arial-BoldMT";
      hv_Fonts[3] = "Arial-BoldItalicMT";
    }
    else if (0 != (hv_Font==HTuple("serif")))
    {
      hv_Fonts.Clear();
      hv_Fonts[0] = "TimesNewRomanPSMT";
      hv_Fonts[1] = "TimesNewRomanPS-ItalicMT";
      hv_Fonts[2] = "TimesNewRomanPS-BoldMT";
      hv_Fonts[3] = "TimesNewRomanPS-BoldItalicMT";
    }
    else
    {
      //Attempt to figure out which of the fonts installed on the system
      //the user could have meant.
      QueryFont(hv_WindowHandle, &hv_SystemFonts);
      hv_Fonts.Clear();
      hv_Fonts.Append(hv_Font);
      hv_Fonts.Append(hv_Font);
      hv_Fonts.Append(hv_Font);
      hv_Fonts.Append(hv_Font);
      hv_Guess.Clear();
      hv_Guess.Append(hv_Font);
      hv_Guess.Append(hv_Font+"-Regular");
      hv_Guess.Append(hv_Font+"MT");
      {
      HTuple end_val100 = (hv_Guess.TupleLength())-1;
      HTuple step_val100 = 1;
      for (hv_I=0; hv_I.Continue(end_val100, step_val100); hv_I += step_val100)
      {
        TupleFind(hv_SystemFonts, HTuple(hv_Guess[hv_I]), &hv_Index);
        if (0 != (hv_Index!=-1))
        {
          hv_Fonts[0] = HTuple(hv_Guess[hv_I]);
          break;
        }
      }
      }
      //Guess name of slanted font
      hv_Guess.Clear();
      hv_Guess.Append(hv_Font+"-Italic");
      hv_Guess.Append(hv_Font+"-ItalicMT");
      hv_Guess.Append(hv_Font+"-Oblique");
      {
      HTuple end_val109 = (hv_Guess.TupleLength())-1;
      HTuple step_val109 = 1;
      for (hv_I=0; hv_I.Continue(end_val109, step_val109); hv_I += step_val109)
      {
        TupleFind(hv_SystemFonts, HTuple(hv_Guess[hv_I]), &hv_Index);
        if (0 != (hv_Index!=-1))
        {
          hv_Fonts[1] = HTuple(hv_Guess[hv_I]);
          break;
        }
      }
      }
      //Guess name of bold font
      hv_Guess.Clear();
      hv_Guess.Append(hv_Font+"-Bold");
      hv_Guess.Append(hv_Font+"-BoldMT");
      {
      HTuple end_val118 = (hv_Guess.TupleLength())-1;
      HTuple step_val118 = 1;
      for (hv_I=0; hv_I.Continue(end_val118, step_val118); hv_I += step_val118)
      {
        TupleFind(hv_SystemFonts, HTuple(hv_Guess[hv_I]), &hv_Index);
        if (0 != (hv_Index!=-1))
        {
          hv_Fonts[2] = HTuple(hv_Guess[hv_I]);
          break;
        }
      }
      }
      //Guess name of bold slanted font
      hv_Guess.Clear();
      hv_Guess.Append(hv_Font+"-BoldItalic");
      hv_Guess.Append(hv_Font+"-BoldItalicMT");
      hv_Guess.Append(hv_Font+"-BoldOblique");
      {
      HTuple end_val127 = (hv_Guess.TupleLength())-1;
      HTuple step_val127 = 1;
      for (hv_I=0; hv_I.Continue(end_val127, step_val127); hv_I += step_val127)
      {
        TupleFind(hv_SystemFonts, HTuple(hv_Guess[hv_I]), &hv_Index);
        if (0 != (hv_Index!=-1))
        {
          hv_Fonts[3] = HTuple(hv_Guess[hv_I]);
          break;
        }
      }
      }
    }
    hv_Font = ((const HTuple&)hv_Fonts)[hv_SubFamily];
    try
    {
      SetFont(hv_WindowHandle, (hv_Font+"-")+hv_Size);
    }
    // catch (Exception) 
    catch (HalconCpp::HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      //throw (Exception)
    }
  }
  else
  {
    //Set font for UNIX systems
    hv_Size = hv_Size*1.25;
    hv_AllowedFontSizes.Clear();
    hv_AllowedFontSizes[0] = 11;
    hv_AllowedFontSizes[1] = 14;
    hv_AllowedFontSizes[2] = 17;
    hv_AllowedFontSizes[3] = 20;
    hv_AllowedFontSizes[4] = 25;
    hv_AllowedFontSizes[5] = 34;
    if (0 != ((hv_AllowedFontSizes.TupleFind(hv_Size))==-1))
    {
      hv_Distances = (hv_AllowedFontSizes-hv_Size).TupleAbs();
      TupleSortIndex(hv_Distances, &hv_Indices);
      hv_Size = ((const HTuple&)hv_AllowedFontSizes)[HTuple(hv_Indices[0])];
    }
    if (0 != (HTuple(hv_Font==HTuple("mono")).TupleOr(hv_Font==HTuple("Courier"))))
    {
      hv_Font = "courier";
    }
    else if (0 != (hv_Font==HTuple("sans")))
    {
      hv_Font = "helvetica";
    }
    else if (0 != (hv_Font==HTuple("serif")))
    {
      hv_Font = "times";
    }
    if (0 != (hv_Bold==HTuple("true")))
    {
      hv_Bold = "bold";
    }
    else if (0 != (hv_Bold==HTuple("false")))
    {
      hv_Bold = "medium";
    }
    else
    {
      hv_Exception = "Wrong value of control parameter Bold";
      throw HalconCpp::HException(hv_Exception);
    }
    if (0 != (hv_Slant==HTuple("true")))
    {
      if (0 != (hv_Font==HTuple("times")))
      {
        hv_Slant = "i";
      }
      else
      {
        hv_Slant = "o";
      }
    }
    else if (0 != (hv_Slant==HTuple("false")))
    {
      hv_Slant = "r";
    }
    else
    {
      hv_Exception = "Wrong value of control parameter Slant";
      throw HalconCpp::HException(hv_Exception);
    }
    try
    {
      SetFont(hv_WindowHandle, ((((((("-adobe-"+hv_Font)+"-")+hv_Bold)+"-")+hv_Slant)+"-normal-*-")+hv_Size)+"-*-*-*-*-*-*-*");
    }
    // catch (Exception) 
    catch (HalconCpp::HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      if (0 != (HTuple((hv_OS.TupleSubstr(0,4))==HTuple("Linux")).TupleAnd(hv_Font==HTuple("courier"))))
      {
        QueryFont(hv_WindowHandle, &hv_Fonts);
        hv_FontSelRegexp = (("^-[^-]*-[^-]*[Cc]ourier[^-]*-"+hv_Bold)+"-")+hv_Slant;
        hv_FontsCourier = (hv_Fonts.TupleRegexpSelect(hv_FontSelRegexp)).TupleRegexpMatch(hv_FontSelRegexp);
        if (0 != ((hv_FontsCourier.TupleLength())==0))
        {
          hv_Exception = "Wrong font name";
          //throw (Exception)
        }
        else
        {
          try
          {
            SetFont(hv_WindowHandle, ((HTuple(hv_FontsCourier[0])+"-normal-*-")+hv_Size)+"-*-*-*-*-*-*-*");
          }
          // catch (Exception) 
          catch (HalconCpp::HException &HDevExpDefaultException)
          {
            HDevExpDefaultException.ToHTuple(&hv_Exception);
            //throw (Exception)
          }
        }
      }
      //throw (Exception)
    }
  }
  // dev_set_preferences(...); only in hdevelop
  return;
}

// Chapter: Graphics / Text
// Short Description: This procedure displays 'Click 'Run' to continue' in the lower right corner of the screen. 
void disp_continue_message (HTuple hv_WindowHandle, HTuple hv_Color, HTuple hv_Box)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_ContinueMessage, hv_Row, hv_Column;
  HTuple  hv_Width, hv_Height, hv_Ascent, hv_Descent, hv_TextWidth;
  HTuple  hv_TextHeight;

  //This procedure displays 'Press Run (F5) to continue' in the
  //lower right corner of the screen.
  //It uses the procedure disp_message.
  //
  //Input parameters:
  //WindowHandle: The window, where the text shall be displayed
  //Color: defines the text color.
  //   If set to '' or 'auto', the currently set color is used.
  //Box: If set to 'true', the text is displayed in a box.
  //
  hv_ContinueMessage = "Press Run (F5) to continue";
  GetWindowExtents(hv_WindowHandle, &hv_Row, &hv_Column, &hv_Width, &hv_Height);
  GetStringExtents(hv_WindowHandle, (" "+hv_ContinueMessage)+" ", &hv_Ascent, &hv_Descent, 
      &hv_TextWidth, &hv_TextHeight);
  disp_message(hv_WindowHandle, hv_ContinueMessage, "window", (hv_Height-hv_TextHeight)-12, 
      (hv_Width-hv_TextWidth)-12, hv_Color, hv_Box);
  return;
}

// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_message (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
    HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Red, hv_Green, hv_Blue, hv_Row1Part;
  HTuple  hv_Column1Part, hv_Row2Part, hv_Column2Part, hv_RowWin;
  HTuple  hv_ColumnWin, hv_WidthWin, hv_HeightWin, hv_MaxAscent;
  HTuple  hv_MaxDescent, hv_MaxWidth, hv_MaxHeight, hv_R1;
  HTuple  hv_C1, hv_FactorRow, hv_FactorColumn, hv_UseShadow;
  HTuple  hv_ShadowColor, hv_Exception, hv_Width, hv_Index;
  HTuple  hv_Ascent, hv_Descent, hv_W, hv_H, hv_FrameHeight;
  HTuple  hv_FrameWidth, hv_R2, hv_C2, hv_DrawMode, hv_CurrentColor;

  //This procedure displays text in a graphics window.
  //
  //Input parameters:
  //WindowHandle: The WindowHandle of the graphics window, where
  //   the message should be displayed
  //String: A tuple of strings containing the text message to be displayed
  //CoordSystem: If set to 'window', the text position is given
  //   with respect to the window coordinate system.
  //   If set to 'image', image coordinates are used.
  //   (This may be useful in zoomed images.)
  //Row: The row coordinate of the desired text position
  //   If set to -1, a default value of 12 is used.
  //Column: The column coordinate of the desired text position
  //   If set to -1, a default value of 12 is used.
  //Color: defines the color of the text as string.
  //   If set to [], '' or 'auto' the currently set color is used.
  //   If a tuple of strings is passed, the colors are used cyclically
  //   for each new textline.
  //Box: If Box[0] is set to 'true', the text is written within an orange box.
  //     If set to' false', no box is displayed.
  //     If set to a color string (e.g. 'white', '#FF00CC', etc.),
  //       the text is written in a box of that color.
  //     An optional second value for Box (Box[1]) controls if a shadow is displayed:
  //       'true' -> display a shadow in a default color
  //       'false' -> display no shadow (same as if no second value is given)
  //       otherwise -> use given string as color string for the shadow color
  //
  //Prepare window
  GetRgb(hv_WindowHandle, &hv_Red, &hv_Green, &hv_Blue);
  GetPart(hv_WindowHandle, &hv_Row1Part, &hv_Column1Part, &hv_Row2Part, &hv_Column2Part);
  GetWindowExtents(hv_WindowHandle, &hv_RowWin, &hv_ColumnWin, &hv_WidthWin, &hv_HeightWin);
  SetPart(hv_WindowHandle, 0, 0, hv_HeightWin-1, hv_WidthWin-1);
  //
  //default settings
  if (0 != (hv_Row==-1))
  {
    hv_Row = 12;
  }
  if (0 != (hv_Column==-1))
  {
    hv_Column = 12;
  }
  if (0 != (hv_Color==HTuple()))
  {
    hv_Color = "";
  }
  //
  hv_String = ((""+hv_String)+"").TupleSplit("\n");
  //
  //Estimate extentions of text depending on font size.
  GetFontExtents(hv_WindowHandle, &hv_MaxAscent, &hv_MaxDescent, &hv_MaxWidth, &hv_MaxHeight);
  if (0 != (hv_CoordSystem==HTuple("window")))
  {
    hv_R1 = hv_Row;
    hv_C1 = hv_Column;
  }
  else
  {
    //Transform image to window coordinates
    hv_FactorRow = (1.*hv_HeightWin)/((hv_Row2Part-hv_Row1Part)+1);
    hv_FactorColumn = (1.*hv_WidthWin)/((hv_Column2Part-hv_Column1Part)+1);
    hv_R1 = ((hv_Row-hv_Row1Part)+0.5)*hv_FactorRow;
    hv_C1 = ((hv_Column-hv_Column1Part)+0.5)*hv_FactorColumn;
  }
  //
  //Display text box depending on text size
  hv_UseShadow = 1;
  hv_ShadowColor = "gray";
  if (0 != (HTuple(hv_Box[0])==HTuple("true")))
  {
    hv_Box[0] = "#fce9d4";
    hv_ShadowColor = "#f28d26";
  }
  if (0 != ((hv_Box.TupleLength())>1))
  {
    if (0 != (HTuple(hv_Box[1])==HTuple("true")))
    {
      //Use default ShadowColor set above
    }
    else if (0 != (HTuple(hv_Box[1])==HTuple("false")))
    {
      hv_UseShadow = 0;
    }
    else
    {
      hv_ShadowColor = ((const HTuple&)hv_Box)[1];
      //Valid color?
      try
      {
        SetColor(hv_WindowHandle, HTuple(hv_Box[1]));
      }
      // catch (Exception) 
      catch (HalconCpp::HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        hv_Exception = "Wrong value of control parameter Box[1] (must be a 'true', 'false', or a valid color string)";
        throw HalconCpp::HException(hv_Exception);
      }
    }
  }
  if (0 != (HTuple(hv_Box[0])!=HTuple("false")))
  {
    //Valid color?
    try
    {
      SetColor(hv_WindowHandle, HTuple(hv_Box[0]));
    }
    // catch (Exception) 
    catch (HalconCpp::HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      hv_Exception = "Wrong value of control parameter Box[0] (must be a 'true', 'false', or a valid color string)";
      throw HalconCpp::HException(hv_Exception);
    }
    //Calculate box extents
    hv_String = (" "+hv_String)+" ";
    hv_Width = HTuple();
    {
    HTuple end_val93 = (hv_String.TupleLength())-1;
    HTuple step_val93 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val93, step_val93); hv_Index += step_val93)
    {
      GetStringExtents(hv_WindowHandle, HTuple(hv_String[hv_Index]), &hv_Ascent, 
          &hv_Descent, &hv_W, &hv_H);
      hv_Width = hv_Width.TupleConcat(hv_W);
    }
    }
    hv_FrameHeight = hv_MaxHeight*(hv_String.TupleLength());
    hv_FrameWidth = (HTuple(0).TupleConcat(hv_Width)).TupleMax();
    hv_R2 = hv_R1+hv_FrameHeight;
    hv_C2 = hv_C1+hv_FrameWidth;
    //Display rectangles
    GetDraw(hv_WindowHandle, &hv_DrawMode);
    SetDraw(hv_WindowHandle, "fill");
    //Set shadow color
    SetColor(hv_WindowHandle, hv_ShadowColor);
    if (0 != hv_UseShadow)
    {
      DispRectangle1(hv_WindowHandle, hv_R1+1, hv_C1+1, hv_R2+1, hv_C2+1);
    }
    //Set box color
    SetColor(hv_WindowHandle, HTuple(hv_Box[0]));
    DispRectangle1(hv_WindowHandle, hv_R1, hv_C1, hv_R2, hv_C2);
    SetDraw(hv_WindowHandle, hv_DrawMode);
  }
  //Write text.
  {
  HTuple end_val115 = (hv_String.TupleLength())-1;
  HTuple step_val115 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val115, step_val115); hv_Index += step_val115)
  {
    hv_CurrentColor = ((const HTuple&)hv_Color)[hv_Index%(hv_Color.TupleLength())];
    if (0 != (HTuple(hv_CurrentColor!=HTuple("")).TupleAnd(hv_CurrentColor!=HTuple("auto"))))
    {
      SetColor(hv_WindowHandle, hv_CurrentColor);
    }
    else
    {
      SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
    }
    hv_Row = hv_R1+(hv_MaxHeight*hv_Index);
    SetTposition(hv_WindowHandle, hv_Row, hv_C1);
    WriteString(hv_WindowHandle, HTuple(hv_String[hv_Index]));
  }
  }
  //Reset changed window settings
  SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
  SetPart(hv_WindowHandle, hv_Row1Part, hv_Column1Part, hv_Row2Part, hv_Column2Part);
  return;
}

// Local procedures 
void dev_display_profile_line (HTuple hv_Row, HTuple hv_Col, HTuple hv_Phi, HTuple hv_Length1, 
    HTuple hv_Length2)
{

  // Local iconic variables
  HObject  ho_CProfile, ho_CArrow, ho_CMidPoint;

  // Local control variables
  HTuple  hv_ArrowAngle, hv_ArrowLength, hv_PSize;
  HTuple  hv_RowStart, hv_RowEnd, hv_ColStart, hv_ColEnd;

  hv_ArrowAngle = (HTuple(45).TupleRad())/2;
  hv_ArrowLength = hv_Length1*0.2;
  hv_PSize = hv_Length2*0.2;
  hv_RowStart = hv_Row+((hv_Phi.TupleSin())*hv_Length1);
  hv_RowEnd = hv_Row-((hv_Phi.TupleSin())*hv_Length1);
  hv_ColStart = hv_Col-((hv_Phi.TupleCos())*hv_Length1);
  hv_ColEnd = hv_Col+((hv_Phi.TupleCos())*hv_Length1);
  GenContourPolygonXld(&ho_CProfile, hv_RowStart.TupleConcat(hv_RowEnd), hv_ColStart.TupleConcat(hv_ColEnd));
  GenContourPolygonXld(&ho_CArrow, ((hv_RowEnd-(((hv_ArrowAngle-hv_Phi).TupleSin())*hv_ArrowLength)).TupleConcat(hv_RowEnd)).TupleConcat(hv_RowEnd+(((hv_ArrowAngle+hv_Phi).TupleSin())*hv_ArrowLength)), 
      ((hv_ColEnd-(((hv_ArrowAngle-hv_Phi).TupleCos())*hv_ArrowLength)).TupleConcat(hv_ColEnd)).TupleConcat(hv_ColEnd-(((hv_ArrowAngle+hv_Phi).TupleCos())*hv_ArrowLength)));
  GenContourPolygonXld(&ho_CMidPoint, (hv_Row-((((HTuple(90).TupleRad())+hv_Phi).TupleSin())*hv_PSize)).TupleConcat(hv_Row-(((hv_Phi-(HTuple(90).TupleRad())).TupleSin())*hv_PSize)), 
      (hv_Col+((((HTuple(90).TupleRad())+hv_Phi).TupleCos())*hv_PSize)).TupleConcat(hv_Col+(((hv_Phi-(HTuple(90).TupleRad())).TupleCos())*hv_PSize)));
  if (HDevWindowStack::IsOpen())
    SetLineWidth(HDevWindowStack::GetActive(),4);
  if (HDevWindowStack::IsOpen())
    SetColor(HDevWindowStack::GetActive(),"white");
  if (HDevWindowStack::IsOpen())
    DispObj(ho_CProfile, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    DispObj(ho_CArrow, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    SetLineWidth(HDevWindowStack::GetActive(),2);
  if (HDevWindowStack::IsOpen())
    SetColor(HDevWindowStack::GetActive(),"black");
  if (HDevWindowStack::IsOpen())
    DispObj(ho_CProfile, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    DispObj(ho_CArrow, HDevWindowStack::GetActive());
  return;
}

void dev_display_measure_object (HTuple hv_Row, HTuple hv_Col, HTuple hv_Phi, HTuple hv_Length1, 
    HTuple hv_Length2)
{

  // Local iconic variables
  HObject  ho_Contour;

  // Local control variables
  HTuple  hv_RowStart, hv_RowEnd, hv_ColStart, hv_ColEnd;
  HTuple  hv_drow, hv_dcol;

  hv_RowStart = hv_Row+((hv_Phi.TupleSin())*hv_Length1);
  hv_RowEnd = hv_Row-((hv_Phi.TupleSin())*hv_Length1);
  hv_ColStart = hv_Col-((hv_Phi.TupleCos())*hv_Length1);
  hv_ColEnd = hv_Col+((hv_Phi.TupleCos())*hv_Length1);
  hv_drow = (((HTuple(90).TupleRad())-hv_Phi).TupleSin())*hv_Length2;
  hv_dcol = (((HTuple(90).TupleRad())-hv_Phi).TupleCos())*hv_Length2;
  GenContourPolygonXld(&ho_Contour, ((((hv_RowStart-hv_drow).TupleConcat(hv_RowEnd-hv_drow)).TupleConcat(hv_RowEnd+hv_drow)).TupleConcat(hv_RowStart+hv_drow)).TupleConcat(hv_RowStart-hv_drow), 
      ((((hv_ColStart-hv_dcol).TupleConcat(hv_ColEnd-hv_dcol)).TupleConcat(hv_ColEnd+hv_dcol)).TupleConcat(hv_ColStart+hv_dcol)).TupleConcat(hv_ColStart-hv_dcol));
  if (HDevWindowStack::IsOpen())
    SetLineWidth(HDevWindowStack::GetActive(),2);
  if (HDevWindowStack::IsOpen())
    SetColor(HDevWindowStack::GetActive(),"green");
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Contour, HDevWindowStack::GetActive());
  dev_display_profile_line(hv_Row, hv_Col, hv_Phi, hv_Length1, hv_Length2);
  return;
}

void dev_display_profile_points (HTuple hv_PRows, HTuple hv_PCols, HTuple hv_Row, 
    HTuple hv_Col, HTuple hv_Phi, HTuple hv_Length1, HTuple hv_Length2)
{

  // Local iconic variables
  HObject  ho_CPoint;

  // Local control variables
  HTuple  hv_PSize, hv_RowStart, hv_RowEnd, hv_ColStart;
  HTuple  hv_ColEnd, hv_idx;

  hv_PSize = hv_Length2*0.5;
  hv_RowStart = hv_Row+((hv_Phi.TupleSin())*hv_Length1);
  hv_RowEnd = hv_Row-((hv_Phi.TupleSin())*hv_Length1);
  hv_ColStart = hv_Col-((hv_Phi.TupleCos())*hv_Length1);
  hv_ColEnd = hv_Col+((hv_Phi.TupleCos())*hv_Length1);
  {
  HTuple end_val5 = (hv_PRows.TupleLength())-1;
  HTuple step_val5 = 1;
  for (hv_idx=0; hv_idx.Continue(end_val5, step_val5); hv_idx += step_val5)
  {
    GenContourPolygonXld(&ho_CPoint, (HTuple(hv_PRows[hv_idx])-((((HTuple(90).TupleRad())+hv_Phi).TupleSin())*hv_PSize)).TupleConcat(HTuple(hv_PRows[hv_idx])-(((hv_Phi-(HTuple(90).TupleRad())).TupleSin())*hv_PSize)), 
        (HTuple(hv_PCols[hv_idx])+((((HTuple(90).TupleRad())+hv_Phi).TupleCos())*hv_PSize)).TupleConcat(HTuple(hv_PCols[hv_idx])+(((hv_Phi-(HTuple(90).TupleRad())).TupleCos())*hv_PSize)));
    if (HDevWindowStack::IsOpen())
      SetColor(HDevWindowStack::GetActive(),"red");
    if (HDevWindowStack::IsOpen())
      SetLineWidth(HDevWindowStack::GetActive(),3);
    if (HDevWindowStack::IsOpen())
      DispObj(ho_CPoint, HDevWindowStack::GetActive());
  }
  }
  return;
}

// Short Description: Displays text right of the center of two given points. 
void p_disp_text_right_of_center (HTuple hv_WindowHandle, HTuple hv_Text, HTuple hv_RowFirst, 
    HTuple hv_ColFirst, HTuple hv_RowSecond, HTuple hv_ColSecond, HTuple hv_Phi, 
    HTuple hv_Distance)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Row1Part, hv_Column1Part, hv_Row2Part;
  HTuple  hv_Column2Part, hv_RowWin, hv_ColumnWin, hv_WidthWin;
  HTuple  hv_HeightWin, hv_FactorRow, hv_FactorColumn, hv_Ascent;
  HTuple  hv_Descent, hv_Width, hv_Height, hv_RowCenter, hv_ColCenter;
  HTuple  hv_RowPos, hv_ColPos, hv_RowText, hv_ColText;

  //Determine factors for the adaptation of the string extents that might be necessary
  //because of image zooming.
  GetPart(hv_WindowHandle, &hv_Row1Part, &hv_Column1Part, &hv_Row2Part, &hv_Column2Part);
  GetWindowExtents(hv_WindowHandle, &hv_RowWin, &hv_ColumnWin, &hv_WidthWin, &hv_HeightWin);
  hv_FactorRow = (1.*((hv_Row2Part-hv_Row1Part)+1))/hv_HeightWin;
  hv_FactorColumn = (1.*((hv_Column2Part-hv_Column1Part)+1))/hv_WidthWin;
  //
  //Determine the extent of the string and its position.
  GetStringExtents(hv_WindowHandle, hv_Text, &hv_Ascent, &hv_Descent, &hv_Width, 
      &hv_Height);
  hv_Width = hv_Width*hv_FactorColumn;
  hv_Height = hv_Height*hv_FactorRow;
  hv_RowCenter = (hv_RowFirst+hv_RowSecond)/2.0;
  hv_ColCenter = (hv_ColFirst+hv_ColSecond)/2.0;
  if (0 != ((hv_Phi.TupleSin())<0))
  {
    hv_Distance = -hv_Distance;
  }
  hv_RowPos = hv_RowCenter+(hv_Distance*(hv_Phi.TupleCos()));
  hv_ColPos = hv_ColCenter+(hv_Distance*(hv_Phi.TupleSin()));
  hv_RowText = hv_RowPos-(hv_Height/2.0);
  hv_ColText = hv_ColPos;
  //
  //Set the text position and color and display the text.
  SetTposition(hv_WindowHandle, hv_RowText, hv_ColText);
  if (HDevWindowStack::IsOpen())
    SetColor(HDevWindowStack::GetActive(),"black");
  WriteString(hv_WindowHandle, hv_Text);
  return;
}

// Short Description: Displays a marker, which indicates the position of an edge 
void p_disp_edge_marker (HTuple hv_Row, HTuple hv_Col, HTuple hv_Phi, HTuple hv_Length, 
    HTuple hv_Color, HTuple hv_LineWidth, HTuple hv_WindowHandle)
{

  // Local iconic variables
  HObject  ho_Marker;

  // Local control variables
  HTuple  hv_RowStart, hv_RowEnd, hv_ColStart, hv_ColEnd;

  //Determine start and end point of the edge marker.
  hv_RowStart = hv_Row+(hv_Length*(hv_Phi.TupleCos()));
  hv_RowEnd = hv_Row-(hv_Length*(hv_Phi.TupleCos()));
  hv_ColStart = hv_Col+(hv_Length*(hv_Phi.TupleSin()));
  hv_ColEnd = hv_Col-(hv_Length*(hv_Phi.TupleSin()));
  //
  //Generate a contour that connects the start and end point.
  GenContourPolygonXld(&ho_Marker, hv_RowStart.TupleConcat(hv_RowEnd), hv_ColStart.TupleConcat(hv_ColEnd));
  //
  //Display the contour with  the specified style.
  if (HDevWindowStack::IsOpen())
    SetColor(HDevWindowStack::GetActive(),hv_Color);
  if (HDevWindowStack::IsOpen())
    SetLineWidth(HDevWindowStack::GetActive(),hv_LineWidth);
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Marker, HDevWindowStack::GetActive());
  //
  //Reset the line width.
  if (HDevWindowStack::IsOpen())
    SetLineWidth(HDevWindowStack::GetActive(),1);
  return;
}

// Short Description: Displays text right of the center of two given points. 
void p_disp_text_left_of_center (HTuple hv_WindowHandle, HTuple hv_Text, HTuple hv_RowFirst, 
    HTuple hv_ColFirst, HTuple hv_RowSecond, HTuple hv_ColSecond, HTuple hv_Phi, 
    HTuple hv_Distance)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Row1Part, hv_Column1Part, hv_Row2Part;
  HTuple  hv_Column2Part, hv_RowWin, hv_ColumnWin, hv_WidthWin;
  HTuple  hv_HeightWin, hv_FactorRow, hv_FactorColumn, hv_Ascent;
  HTuple  hv_Descent, hv_Width, hv_Height, hv_RowCenter, hv_ColCenter;
  HTuple  hv_RowPos, hv_ColPos, hv_RowText, hv_ColText;

  //Determine factors for the adaptation of the string extents that might be necessary
  //because of image zooming.
  GetPart(hv_WindowHandle, &hv_Row1Part, &hv_Column1Part, &hv_Row2Part, &hv_Column2Part);
  GetWindowExtents(hv_WindowHandle, &hv_RowWin, &hv_ColumnWin, &hv_WidthWin, &hv_HeightWin);
  hv_FactorRow = (1.*((hv_Row2Part-hv_Row1Part)+1))/hv_HeightWin;
  hv_FactorColumn = (1.*((hv_Column2Part-hv_Column1Part)+1))/hv_WidthWin;
  //
  //Determine the extent of the string and its position.
  GetStringExtents(hv_WindowHandle, hv_Text, &hv_Ascent, &hv_Descent, &hv_Width, 
      &hv_Height);
  hv_Width = hv_Width*hv_FactorColumn;
  hv_Height = hv_Height*hv_FactorRow;
  hv_RowCenter = (hv_RowFirst+hv_RowSecond)/2.0;
  hv_ColCenter = (hv_ColFirst+hv_ColSecond)/2.0;
  if (0 != ((hv_Phi.TupleSin())<0))
  {
    hv_Distance = -hv_Distance;
  }
  hv_RowPos = hv_RowCenter-(hv_Distance*(hv_Phi.TupleCos()));
  hv_ColPos = hv_ColCenter-(hv_Distance*(hv_Phi.TupleSin()));
  hv_RowText = hv_RowPos-(hv_Height/2.0);
  hv_ColText = hv_ColPos-hv_Width;
  //
  //Set the text position and color and display the text.
  SetTposition(hv_WindowHandle, hv_RowText, hv_ColText);
  if (HDevWindowStack::IsOpen())
    SetColor(HDevWindowStack::GetActive(),"black");
  WriteString(hv_WindowHandle, hv_Text);
  return;
}

// Short Description: Displays the dimension of the measured edge pairs. 
void p_disp_dimensions (HTuple hv_RowEdgeFirst, HTuple hv_ColumnEdgeFirst, HTuple hv_RowEdgeSecond, 
    HTuple hv_ColumnEdgeSecond, HTuple hv_IntraDistance, HTuple hv_InterDistance, 
    HTuple hv_Phi, HTuple hv_Length, HTuple hv_WindowHandle)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Number, hv_i, hv_Text;

  //Loop over all edge pairs.
  hv_Number = hv_RowEdgeFirst.TupleLength();
  {
  HTuple end_val2 = hv_Number-1;
  HTuple step_val2 = 1;
  for (hv_i=0; hv_i.Continue(end_val2, step_val2); hv_i += step_val2)
  {
    //
    //Display markers for the edges.
    p_disp_edge_marker(HTuple(hv_RowEdgeFirst[hv_i]), HTuple(hv_ColumnEdgeFirst[hv_i]), 
        hv_Phi, hv_Length, "white", 2, hv_WindowHandle);
    p_disp_edge_marker(HTuple(hv_RowEdgeSecond[hv_i]), HTuple(hv_ColumnEdgeSecond[hv_i]), 
        hv_Phi, hv_Length, "white", 2, hv_WindowHandle);
    //
    //Display the IntraDistance between the edges.
    hv_Text = ((const HTuple&)hv_IntraDistance)[hv_i];
    p_disp_text_right_of_center(hv_WindowHandle, hv_Text.TupleString(".2f"), HTuple(hv_RowEdgeFirst[hv_i]), 
        HTuple(hv_ColumnEdgeFirst[hv_i]), HTuple(hv_RowEdgeSecond[hv_i]), HTuple(hv_ColumnEdgeSecond[hv_i]), 
        hv_Phi, 2.0*hv_Length);
  }
  }
  //
  //Loop to display the distance between the edge pairs.
  {
  HTuple end_val14 = hv_Number-2;
  HTuple step_val14 = 1;
  for (hv_i=0; hv_i.Continue(end_val14, step_val14); hv_i += step_val14)
  {
    //
    //Display the InterDistance between the edge pairs.
    hv_Text = ((const HTuple&)hv_InterDistance)[hv_i];
    p_disp_text_left_of_center(hv_WindowHandle, hv_Text.TupleString(".2f"), HTuple(hv_RowEdgeSecond[hv_i]), 
        HTuple(hv_ColumnEdgeSecond[hv_i]), HTuple(hv_RowEdgeFirst[hv_i+1]), HTuple(hv_ColumnEdgeFirst[hv_i+1]), 
        hv_Phi, 2.0*hv_Length);
  }
  }
  return;
}

void get_tmp_dir (HTuple *hv_LocalTemp)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_FileExists;

  TupleEnvironment("TEMP", &(*hv_LocalTemp));
  if (0 != ((*hv_LocalTemp)==HTuple("")))
  {
    TupleEnvironment("TMP", &(*hv_LocalTemp));
    if (0 != ((*hv_LocalTemp)==HTuple("")))
    {
      FileExists("/tmp", &hv_FileExists);
      if (0 != hv_FileExists)
      {
        (*hv_LocalTemp) = "/tmp";
      }
      else
      {
        (*hv_LocalTemp) = "./";
      }
    }
  }
  return;
}

void gen_initial_trainfile (HTuple hv_TrainFileName)
{

  // Local iconic variables
  HObject  ho_Image, ho_Region, ho_RegionDilation;
  HObject  ho_ConnectedRegions, ho_RegionIntersection, ho_Characters;

  // Local control variables
  HTuple  hv_UsedThreshold, hv_Number, hv_Classes;
  HTuple  hv_J;

  ReadImage(&ho_Image, "letters");
  //Segment the image.
  BinaryThreshold(ho_Image, &ho_Region, "max_separability", "dark", &hv_UsedThreshold);
  //Connect the i's and j's with their dots.
  DilationCircle(ho_Region, &ho_RegionDilation, 3.5);
  //Compute the correct connected components.
  Connection(ho_RegionDilation, &ho_ConnectedRegions);
  //Reduce each connected component (character) to its original shape.
  Intersection(ho_ConnectedRegions, ho_Region, &ho_RegionIntersection);
  //Sort the characters line-by-line.
  SortRegion(ho_RegionIntersection, &ho_Characters, "character", "true", "row");
  //Compute the true class of each character.
  CountObj(ho_Characters, &hv_Number);
  hv_Classes = HTuple();
  for (hv_J=0; hv_J<=25; hv_J+=1)
  {
    hv_Classes = hv_Classes.TupleConcat(HTuple(20,((HTuple("a").TupleOrd())+hv_J).TupleChr()));
  }
  hv_Classes = hv_Classes.TupleConcat(HTuple(20,"."));
  //Construct the necessary training file from the segmented characters.
  WriteOcrTrainf(ho_Characters, ho_Image, hv_Classes, hv_TrainFileName);
  return;
}

#ifndef NO_EXPORT_MAIN
// Main procedure 
void action()
{

  // Local iconic variables
  HObject  ho_IMAGE_OF_INIT, ho_ROI_0, ho_ImageReduced;
  HObject  ho_Image_temp, ho_RegionAffineTrans, ho_Circle;
  HObject  ho_Image_temp_corp, ho_Image_temp_Mean, ho_Region_temp_DynThresh;
  HObject  ho_Region_temp_Closing, ho_ConnectedRegions, ho_SelectedRegions_char;
  HObject  ho_SelectedRegions_logo, ho_CharsSorted, ho_Characters;
  HObject  ho_RegionDilation, ho_Image_temp_logo;

  // Local control variables
  HTuple  hv_AcqHandle_of_camera, hv_Width_of_window;
  HTuple  hv_Height_of_window, hv_PATH_OF_PICTURE1, hv_PATH_OF_PICTURE2;
  HTuple  hv_PATH_OF_PICTURE3, hv_RowEdgeFirst1_last, hv_ColumnEdgeFirst1_last;
  HTuple  hv_AmplitudeFirst1_last, hv_RowEdgeSecond1_last;
  HTuple  hv_ColumnEdgeSecond1_last, hv_AmplitudeSecond1_last;
  HTuple  hv_PinWidth1_last, hv_PinDistance1_last, hv_RowEdgeFirst2_last;
  HTuple  hv_ColumnEdgeFirst2_last, hv_AmplitudeFirst2_last;
  HTuple  hv_RowEdgeSecond2_last, hv_ColumnEdgeSecond2_last;
  HTuple  hv_AmplitudeSecond2_last, hv_PinWidth2_last, hv_PinDistance2_last;
  HTuple  hv_FLAG_ING_YDS, hv_WindowHandle, hv_Area, hv_RowRef;
  HTuple  hv_ColumnRef, hv_ModelID, hv_Rows, hv_Cols, hv_Row;
  HTuple  hv_Column, hv_Angle, hv_Score, hv_HomMat2D, hv_point_yds_row;
  HTuple  hv_point_yds_col, hv_point_yds_row_crop, hv_point_yds_column_crop;
  HTuple  hv_point_yds_width_crop, hv_point_yds_height_crop;
  HTuple  hv_point_yds_row_logo, hv_point_yds_column_logo;
  HTuple  hv_point_yds_width_logo, hv_point_yds_height_logo;
  HTuple  hv_point_yds_row1, hv_point_yds_column1, hv_point_yds_phi1;
  HTuple  hv_point_yds_Length1, hv_point_yds_Length2, hv_point_yds_row2;
  HTuple  hv_point_yds_column2, hv_point_yds_phi2, hv_point_yds_row3;
  HTuple  hv_point_yds_column3, hv_point_yds_phi3, hv_point_yds_Length3;
  HTuple  hv_point_yds_Length4, hv_MeasureHandle1, hv_MeasureHandle2;
  HTuple  hv_MeasureHandle3, hv_RowEdge, hv_ColumnEdge, hv_Amplitude;
  HTuple  hv_Distance, hv_PinHeight1, hv_PinHeight2, hv_PinHeight3;
  HTuple  hv_n, hv_Seconds1, hv_i, hv_RowEdgeFirst1, hv_ColumnEdgeFirst1;
  HTuple  hv_AmplitudeFirst1, hv_RowEdgeSecond1, hv_ColumnEdgeSecond1;
  HTuple  hv_AmplitudeSecond1, hv_PinWidth1, hv_PinDistance1;
  HTuple  hv_RowEdgeFirst2, hv_ColumnEdgeFirst2, hv_AmplitudeFirst2;
  HTuple  hv_RowEdgeSecond2, hv_ColumnEdgeSecond2, hv_AmplitudeSecond2;
  HTuple  hv_PinWidth2, hv_PinDistance2, hv_shuzuyuansu_geshu;
  HTuple  hv_Seconds2, hv_Time, hv_avgPinWidth1, hv_avgPinDistance1;
  HTuple  hv_numPins1, hv_avgPinWidth2, hv_avgPinDistance2;
  HTuple  hv_numPins2, hv_avgPinDistance, hv_avgPinWidth;
  HTuple  hv_numPins, hv_Sigma, hv_Threshold, hv_Transition;
  HTuple  hv_Select, hv_Offset_dyn_threshod, hv_Radius_closing_circle;
  HTuple  hv_Index, hv_RowCh, hv_ColumnCh, hv_Class, hv_Area1;
  HTuple  hv_IndexL, hv_TmpDir, hv_TrainFile, hv_TrainFileBig;

  //********************************************************************************************************
  //***********************************机器视觉***********************************************************
  //*********************************************************************************************************

  //***********************************变量初始化*********************************************************************
  //Camera
  hv_AcqHandle_of_camera = 0;

  //*WINDOW
  hv_Width_of_window = 0;
  hv_Height_of_window = 0;

  hv_PATH_OF_PICTURE1 = "C:/Users/Administrator/Desktop/HALCON工程/TESTING1.bmp";
  hv_PATH_OF_PICTURE2 = "C:/Users/Administrator/Desktop/HALCON工程/TESTING2.bmp";
  hv_PATH_OF_PICTURE3 = "C:/Users/Administrator/Desktop/HALCON工程/TES7TING3.bmp";

  hv_RowEdgeFirst1_last = 0;
  hv_ColumnEdgeFirst1_last = 0;
  hv_AmplitudeFirst1_last = 0;
  hv_RowEdgeSecond1_last = 0;
  hv_ColumnEdgeSecond1_last = 0;
  hv_AmplitudeSecond1_last = 0;
  hv_PinWidth1_last = 0;
  hv_PinDistance1_last = 0;

  hv_RowEdgeFirst2_last = 0;
  hv_ColumnEdgeFirst2_last = 0;
  hv_AmplitudeFirst2_last = 0;
  hv_RowEdgeSecond2_last = 0;
  hv_ColumnEdgeSecond2_last = 0;
  hv_AmplitudeSecond2_last = 0;
  hv_PinWidth2_last = 0;
  hv_PinDistance2_last = 0;

  //**标志位*****程序是否正常运行*****
  hv_FLAG_ING_YDS = 0;

  //***********************************相机的初始化*********************************************************************

  //Image Acquisition 01: Code generated by Image Acquisition 01
  OpenFramegrabber("DirectShow", 1, 1, 0, 0, 0, 0, "default", 8, "gray", -1, "false", 
      "default", "[0]  Camera MV-U130M#3DF11190-3", 0, -1, &hv_AcqHandle_of_camera);
  GrabImageStart(hv_AcqHandle_of_camera, -1);

  //**截图工具
  //grab_image_async (Image, AcqHandle, -1)
  //dump_window (3600, 'bmp', 'C:/Users/Administrator/Desktop/HALCON工程/TESTING3')

  //**************************************窗口和图像的初始化**************************************************

  //Image Acquisition 01: Do something
  //**为了防止初始位置的更换，只做了模板图片读取，
  //**后期计划：读取的自识别
  //***白底的图片
  //read_image (IMAGE_OF_INIT, 'C:/Users/Administrator/Desktop/HALCON工程/TESTING2.bmp')
  //***黑底的图片
  ReadImage(&ho_IMAGE_OF_INIT, hv_PATH_OF_PICTURE1);
  //***黑底的图片2
  //read_image (IMAGE_OF_INIT, 'C:/Users/Administrator/Desktop/HALCON工程/TESTING3.bmp')
  //**获取图片的大小： 130万像素 ： 1280*1024 bmp格式
  GetImageSize(ho_IMAGE_OF_INIT, &hv_Width_of_window, &hv_Height_of_window);
  //dev_close_window ()
  //**新打开窗口，为以后在VS2015环境下调试下方便！
  //*大小：640*512尺寸的窗口
  SetWindowAttr("background_color","black");
  OpenWindow(0,0,hv_Width_of_window/2,hv_Height_of_window/2,0,"","",&hv_WindowHandle);
  HDevWindowStack::Push(hv_WindowHandle);
  //dump_window (3600, 'jpeg', 'C:/Users/Administrator/Desktop/HALCON工程/Template')
  if (HDevWindowStack::IsOpen())
    DispObj(ho_IMAGE_OF_INIT, HDevWindowStack::GetActive());


  //*****************************************NCC区域选择以及初始化***************************************************************

  //**矩形的位置选择
  GenRectangle1(&ho_ROI_0, 172.514, 343.75, 939.005, 946.662);
  //gen_rectangle1 (ROI_0, 138.167, 293.968, 948.833, 964.606)
  //gen_rectangle1 (ROI_0, 138.167/2, 293.968/2, 948.833/2, 964.606/2)
  //gen_circle (ROI_0, 739.5, 465.5, 185.569)
  //**区域选择
  AreaCenter(ho_ROI_0, &hv_Area, &hv_RowRef, &hv_ColumnRef);
  ReduceDomain(ho_IMAGE_OF_INIT, ho_ROI_0, &ho_ImageReduced);
  //dump_window (3601, 'jpeg', 'C:/Users/Administrator/Desktop/HALCON工程/ImageReduced')
  CreateNccModel(ho_ImageReduced, "auto", 0, 0, "auto", "use_polarity", &hv_ModelID);
  //dump_window (3601, 'jpeg', 'C:/Users/Administrator/Desktop/HALCON工程/ImageReduced')
  //**定义区域填充模式
  if (HDevWindowStack::IsOpen())
    SetDraw(HDevWindowStack::GetActive(),"margin");
  if (HDevWindowStack::IsOpen())
    DispObj(ho_ROI_0, HDevWindowStack::GetActive());
  //stop ()
  hv_Rows = HTuple();
  hv_Cols = HTuple();


  //*******************************核心：机器视觉识别检测*****************************************************

  while (0 != 1)
  {

    //*******************************相机SNAP 相关性匹配（NCC）************************************************************************

    GrabImageAsync(&ho_Image_temp, hv_AcqHandle_of_camera, -1);
    //dump_window (3601, 'bmp', 'C:/Users/Administrator/Desktop/HALCON工程/TESTING')
    //**根据NCC-Model 找到最佳的匹配的区域
    FindNccModel(ho_Image_temp, hv_ModelID, 0, 0, 0.5, 1, 0.5, "true", 0, &hv_Row, 
        &hv_Column, &hv_Angle, &hv_Score);

    //******如果目标不在视野中的情况**************************
    while (0 != (hv_Row==HTuple()))
    {
      GrabImageAsync(&ho_Image_temp, hv_AcqHandle_of_camera, -1);
      //dump_window (3601, 'bmp', 'C:/Users/Administrator/Desktop/HALCON工程/TESTING')
      //**根据NCC-Model 找到最佳的匹配的区域
      FindNccModel(ho_Image_temp, hv_ModelID, 0, 0, 0.5, 1, 0.5, "true", 0, &hv_Row, 
          &hv_Column, &hv_Angle, &hv_Score);
      set_display_font(hv_WindowHandle, 24, "mono", "true", "false");
      disp_message(hv_WindowHandle, "目标物体在视野中不存在或者偏离！！", "image", 
          450, 120, "black", "true");
      disp_message(hv_WindowHandle, "提示：请将物体移动至视野中！！", "image", 516, 
          120, "black", "true");
      set_display_font(hv_WindowHandle, 16, "mono", "true", "false");
      disp_message(hv_WindowHandle, "工作状态：目标偏离", "image", 0, 0, "green", 
          "false");
    }

    //**点和角严格计算的仿射变换
    VectorAngleToRigid(hv_RowRef, hv_ColumnRef, 0, hv_Row, hv_Column, 0, &hv_HomMat2D);
    //disp_message (WindowHandle, ' testing: ', 'window', Row, 0, 'lime green', 'false')
    AffineTransRegion(ho_ROI_0, &ho_RegionAffineTrans, hv_HomMat2D, "nearest_neighbor");
    hv_Rows = hv_Rows.TupleConcat(hv_Row);
    hv_Cols = hv_Cols.TupleConcat(hv_Column);

    //****目标区域位置的选定*******************
    if (HDevWindowStack::IsOpen())
      SetDraw(HDevWindowStack::GetActive(),"margin");
    if (HDevWindowStack::IsOpen())
      SetColor(HDevWindowStack::GetActive(),"red");
    if (HDevWindowStack::IsOpen())
      DispObj(ho_RegionAffineTrans, HDevWindowStack::GetActive());
    //******************************芯片凹原点检测**************************************************************************

    if (HDevWindowStack::IsOpen())
      DispObj(ho_Image_temp, HDevWindowStack::GetActive());
    hv_point_yds_row = hv_Row+133;
    hv_point_yds_col = hv_Column-230;
    GenCircle(&ho_Circle, hv_point_yds_row, hv_point_yds_col, 35);

    //******************************字符和LOGO变量定义************************************************

    //**FOR CHAR shibie
    hv_point_yds_row_crop = hv_Row-180;
    hv_point_yds_column_crop = hv_Column-50;
    hv_point_yds_width_crop = 320;
    hv_point_yds_height_crop = 350;

    //**FOR LOGO
    hv_point_yds_row_logo = hv_Row-160;
    hv_point_yds_column_logo = hv_Column-220;
    hv_point_yds_width_logo = 180;
    hv_point_yds_height_logo = 225;

    //*******************************变量坐标的定义**************************************************************************

    //**define for MeasureHandle1
    hv_point_yds_row1 = hv_Row+300;
    hv_point_yds_column1 = hv_Column;
    hv_point_yds_phi1 = 0;
    //**define for MeasureHandle1 AND MeasureHandle2
    hv_point_yds_Length1 = 298;
    hv_point_yds_Length2 = 55;
    //**define for MeasureHandle2
    hv_point_yds_row2 = hv_Row-310;
    hv_point_yds_column2 = hv_Column;
    hv_point_yds_phi2 = 0-(HTuple(180).TupleRad());

    //**define for MeasureHandle3
    hv_point_yds_row3 = hv_Row;
    hv_point_yds_column3 = hv_Column;
    hv_point_yds_phi3 = HTuple(-90).TupleRad();
    hv_point_yds_Length3 = 410;
    hv_point_yds_Length4 = 298;

    //********************************字体设置*************************************************************************

    if (HDevWindowStack::IsOpen())
      SetColor(HDevWindowStack::GetActive(),"green");
    if (HDevWindowStack::IsOpen())
      SetDraw(HDevWindowStack::GetActive(),"margin");
    if (HDevWindowStack::IsOpen())
      SetLineWidth(HDevWindowStack::GetActive(),3);
    set_display_font(hv_WindowHandle, 14, "mono", "true", "false");

    //********************************引脚相关测量*************************************************************************

    GenMeasureRectangle2(hv_point_yds_row1, hv_point_yds_column1, hv_point_yds_phi1, 
        hv_point_yds_Length1, hv_point_yds_Length2, hv_Width_of_window, hv_Height_of_window, 
        "nearest_neighbor", &hv_MeasureHandle1);
    GenMeasureRectangle2(hv_point_yds_row2, hv_point_yds_column2, hv_point_yds_phi2, 
        hv_point_yds_Length1, hv_point_yds_Length2, hv_Width_of_window, hv_Height_of_window, 
        "nearest_neighbor", &hv_MeasureHandle2);
    GenMeasureRectangle2(hv_point_yds_row3, hv_point_yds_column3, hv_point_yds_phi3, 
        hv_point_yds_Length3, hv_point_yds_Length4, hv_Width_of_window, hv_Height_of_window, 
        "nearest_neighbor", &hv_MeasureHandle3);
    //gen_measure_rectangle2 (Row, Column, point_yds_phi2, point_yds_Length4, point_yds_Length3, Width, Height, 'nearest_neighbor', MeasureHandle4)

    MeasurePos(ho_Image_temp, hv_MeasureHandle3, 1.5, 30, "all", "all", &hv_RowEdge, 
        &hv_ColumnEdge, &hv_Amplitude, &hv_Distance);

    //***防止未检测到值导致的BUG
    if (0 != ((hv_RowEdge.TupleLength())!=4))
    {
      hv_RowEdge[0] = 0;
      hv_RowEdge[1] = 0;
      hv_RowEdge[2] = 0;
      hv_RowEdge[3] = 0;
    }
    if (0 != ((hv_ColumnEdge.TupleLength())!=4))
    {
      hv_ColumnEdge[0] = 500;
      hv_ColumnEdge[1] = 500;
      hv_ColumnEdge[2] = 500;
      hv_ColumnEdge[3] = 500;
    }

    //***检测结果的相关计算
    hv_PinHeight1 = HTuple(hv_RowEdge[1])-HTuple(hv_RowEdge[0]);
    hv_PinHeight2 = HTuple(hv_RowEdge[3])-HTuple(hv_RowEdge[2]);
    hv_PinHeight3 = HTuple(hv_RowEdge[2])-HTuple(hv_RowEdge[1]);
    if (HDevWindowStack::IsOpen())
      SetColor(HDevWindowStack::GetActive(),"blue");
    DispLine(hv_WindowHandle, hv_RowEdge, hv_ColumnEdge-hv_point_yds_Length4, hv_RowEdge, 
        hv_ColumnEdge+hv_point_yds_Length4);

    disp_message(hv_WindowHandle, "Pin Length:  "+hv_PinHeight1, "image", HTuple(hv_RowEdge[1])+40, 
        HTuple(hv_ColumnEdge[1])+100, "yellow", "false");
    disp_message(hv_WindowHandle, "Pin Length:  "+hv_PinHeight2, "image", HTuple(hv_RowEdge[3])-120, 
        HTuple(hv_ColumnEdge[3])+100, "yellow", "false");
    disp_message(hv_WindowHandle, "Cen Length:  "+hv_PinHeight3, "image", HTuple(hv_RowEdge[2])-120, 
        HTuple(hv_ColumnEdge[2])+100, "yellow", "false");

    dev_display_measure_object(hv_point_yds_row1, hv_point_yds_column1, hv_point_yds_phi1, 
        hv_point_yds_Length1, hv_point_yds_Length2);
    dev_display_measure_object(hv_point_yds_row2, hv_point_yds_column2, hv_point_yds_phi2, 
        hv_point_yds_Length1, hv_point_yds_Length2);
    //**COLOR
    //dev_set_color ('red')
    //dev_set_draw ('margin')
    //dev_set_line_width (3)
    //dev_display_measure_object (point_yds_row3, point_yds_column3, point_yds_phi3, point_yds_Length3, point_yds_Length4)

    //disp_continue_message (WindowHandle, 'black', 'true')

    // dev_update_pc(...); only in hdevelop
    // dev_update_var(...); only in hdevelop
    hv_n = 3;
    hv_FLAG_ING_YDS = 0;
    CountSeconds(&hv_Seconds1);
    {
    HTuple end_val222 = hv_n;
    HTuple step_val222 = 1;
    for (hv_i=1; hv_i.Continue(end_val222, step_val222); hv_i += step_val222)
    {
      MeasurePairs(ho_Image_temp, hv_MeasureHandle1, 1.5, 30, "positive_strongest", 
          "all", &hv_RowEdgeFirst1, &hv_ColumnEdgeFirst1, &hv_AmplitudeFirst1, &hv_RowEdgeSecond1, 
          &hv_ColumnEdgeSecond1, &hv_AmplitudeSecond1, &hv_PinWidth1, &hv_PinDistance1);
      MeasurePairs(ho_Image_temp, hv_MeasureHandle2, 1.5, 30, "positive_strongest", 
          "all", &hv_RowEdgeFirst2, &hv_ColumnEdgeFirst2, &hv_AmplitudeFirst2, &hv_RowEdgeSecond2, 
          &hv_ColumnEdgeSecond2, &hv_AmplitudeSecond2, &hv_PinWidth2, &hv_PinDistance2);
      hv_shuzuyuansu_geshu = (((((((hv_RowEdgeFirst1.TupleLength())+(hv_RowEdgeFirst2.TupleLength()))+(hv_ColumnEdgeFirst1.TupleLength()))+(hv_ColumnEdgeFirst2.TupleLength()))+(hv_RowEdgeSecond1.TupleLength()))+(hv_RowEdgeSecond2.TupleLength()))+(hv_ColumnEdgeSecond1.TupleLength()))+(hv_ColumnEdgeSecond2.TupleLength());
      if (0 != (hv_shuzuyuansu_geshu!=32))
      {
        //**对不符合数据的进行停滞
        //**或者是备份正确的一份数据
        //i := 1
        hv_RowEdgeFirst1 = hv_RowEdgeFirst1_last;
        hv_ColumnEdgeFirst1 = hv_ColumnEdgeFirst1_last;
        hv_AmplitudeFirst1 = hv_AmplitudeFirst1_last;
        hv_RowEdgeSecond1 = hv_RowEdgeSecond1_last;
        hv_ColumnEdgeSecond1 = hv_ColumnEdgeSecond1_last;
        hv_AmplitudeSecond1 = hv_AmplitudeSecond1_last;
        hv_PinWidth1 = hv_PinWidth1_last;
        hv_PinDistance1 = hv_PinDistance1_last;

        hv_RowEdgeFirst2 = hv_RowEdgeFirst2_last;
        hv_ColumnEdgeFirst2 = hv_ColumnEdgeFirst2_last;
        hv_AmplitudeFirst2 = hv_AmplitudeFirst2_last;
        hv_RowEdgeSecond2 = hv_RowEdgeSecond2_last;
        hv_ColumnEdgeSecond2 = hv_ColumnEdgeSecond2_last;
        hv_AmplitudeSecond2 = hv_AmplitudeSecond2_last;
        hv_PinWidth2 = hv_PinWidth2_last;
        hv_PinDistance2 = hv_PinDistance2_last;
        disp_message(hv_WindowHandle, "目标物体正在矫正中......", "image", 450, 120, 
            "black", "true");
        set_display_font(hv_WindowHandle, 16, "mono", "true", "false");
        disp_message(hv_WindowHandle, "工作状态：矫正中", "image", 0, 0, "green", 
            "false");
        //****程序的运行还是存在错误的************
        hv_FLAG_ING_YDS = 1;

      }
    }
    }
    CountSeconds(&hv_Seconds2);
    hv_Time = hv_Seconds2-hv_Seconds1;

    //*************做一个数据的备份，防止在移动物体时，出现数据测量的不准确，导致程序出现BUG**********************
    //*************如果数组中的元素个数不满足的要求的话，将会用以前备份的数据进行初始化***************************

    hv_RowEdgeFirst1_last = hv_RowEdgeFirst1;
    hv_ColumnEdgeFirst1_last = hv_ColumnEdgeFirst1;
    hv_AmplitudeFirst1_last = hv_AmplitudeFirst1;
    hv_RowEdgeSecond1_last = hv_RowEdgeSecond1;
    hv_ColumnEdgeSecond1_last = hv_ColumnEdgeSecond1;
    hv_AmplitudeSecond1_last = hv_AmplitudeSecond1;
    hv_PinWidth1_last = hv_PinWidth1;
    hv_PinDistance1_last = hv_PinDistance1;

    hv_RowEdgeFirst2_last = hv_RowEdgeFirst2;
    hv_ColumnEdgeFirst2_last = hv_ColumnEdgeFirst2;
    hv_AmplitudeFirst2_last = hv_AmplitudeFirst2;
    hv_RowEdgeSecond2_last = hv_RowEdgeSecond2;
    hv_ColumnEdgeSecond2_last = hv_ColumnEdgeSecond2;
    hv_AmplitudeSecond2_last = hv_AmplitudeSecond2;
    hv_PinWidth2_last = hv_PinWidth2;
    hv_PinDistance2_last = hv_PinDistance2;

    //********************************检测结果的相关计算*************************************************************************

    disp_continue_message(hv_WindowHandle, "black", "true");
    //stop ()
    if (HDevWindowStack::IsOpen())
      SetColor(HDevWindowStack::GetActive(),"red");
    hv_RowEdgeFirst1.Clear();
    hv_RowEdgeFirst1.Append(hv_point_yds_row1);
    hv_RowEdgeFirst1.Append(hv_point_yds_row1);
    hv_RowEdgeFirst1.Append(hv_point_yds_row1);
    hv_RowEdgeFirst1.Append(hv_point_yds_row1);
    hv_RowEdgeFirst2.Clear();
    hv_RowEdgeFirst2.Append(hv_point_yds_row2);
    hv_RowEdgeFirst2.Append(hv_point_yds_row2);
    hv_RowEdgeFirst2.Append(hv_point_yds_row2);
    hv_RowEdgeFirst2.Append(hv_point_yds_row2);
    //划线的程序************************************
    //*************只有在程序正常与运行的情况下执行
    if (0 != (hv_FLAG_ING_YDS==0))
    {
      DispLine(hv_WindowHandle, hv_RowEdgeFirst1, hv_ColumnEdgeFirst1, hv_RowEdgeSecond1, 
          hv_ColumnEdgeSecond1);
      DispLine(hv_WindowHandle, hv_RowEdgeFirst2, hv_ColumnEdgeFirst2, hv_RowEdgeSecond2, 
          hv_ColumnEdgeSecond2);
    }


    hv_avgPinWidth1 = (hv_PinWidth1.TupleSum())/(hv_PinWidth1.TupleLength());
    hv_avgPinDistance1 = (hv_PinDistance1.TupleSum())/(hv_PinDistance1.TupleLength());
    hv_numPins1 = hv_PinWidth1.TupleLength();

    hv_avgPinWidth2 = (hv_PinWidth2.TupleSum())/(hv_PinWidth2.TupleLength());
    hv_avgPinDistance2 = (hv_PinDistance2.TupleSum())/(hv_PinDistance2.TupleLength());
    hv_numPins2 = hv_PinWidth2.TupleLength();

    hv_avgPinDistance = (hv_avgPinDistance1+hv_avgPinDistance2)/2;
    hv_avgPinWidth = (hv_avgPinWidth1+hv_avgPinWidth2)/2;
    hv_numPins = hv_numPins1+hv_numPins2;


    //********************************显示检测结果*************************************************************************

    if (0 != (hv_FLAG_ING_YDS==0))
    {
      set_display_font(hv_WindowHandle, 16, "mono", "true", "false");
      disp_message(hv_WindowHandle, "工作状态：正常", "image", 0, 0, "green", "false");
      if (HDevWindowStack::IsOpen())
        SetDraw(HDevWindowStack::GetActive(),"margin");
      if (HDevWindowStack::IsOpen())
        SetColor(HDevWindowStack::GetActive(),"red");
      if (HDevWindowStack::IsOpen())
        DispObj(ho_RegionAffineTrans, HDevWindowStack::GetActive());
      if (HDevWindowStack::IsOpen())
        SetColor(HDevWindowStack::GetActive(),"yellow");
      disp_message(hv_WindowHandle, "Standard measure results", "window", 28, 0, 
          "black", "true");
      disp_message(hv_WindowHandle, "Number of pins: "+hv_numPins, "image", 100, 
          12, "yellow", "false");
      disp_message(hv_WindowHandle, "Pin_1 Width:  "+HTuple(hv_PinWidth1[0]), "image", 
          130, 12, "yellow", "false");
      disp_message(hv_WindowHandle, "Pin_2 Width:  "+HTuple(hv_PinWidth1[1]), "image", 
          160, 12, "yellow", "false");
      disp_message(hv_WindowHandle, "Pin_3 Width:  "+HTuple(hv_PinWidth1[2]), "image", 
          190, 12, "yellow", "false");
      disp_message(hv_WindowHandle, "Pin_4 Width:  "+HTuple(hv_PinWidth1[3]), "image", 
          220, 12, "yellow", "false");
      disp_message(hv_WindowHandle, "Pin_5 Width:  "+HTuple(hv_PinWidth2[0]), "image", 
          250, 12, "yellow", "false");
      disp_message(hv_WindowHandle, "Pin_6 Width:  "+HTuple(hv_PinWidth2[1]), "image", 
          280, 12, "yellow", "false");
      disp_message(hv_WindowHandle, "Pin_7 Width:  "+HTuple(hv_PinWidth2[2]), "image", 
          310, 12, "yellow", "false");
      disp_message(hv_WindowHandle, "Pin_8 Width:  "+HTuple(hv_PinWidth2[3]), "image", 
          340, 12, "yellow", "false");
      disp_message(hv_WindowHandle, "Dis_1 Width:  "+HTuple(hv_PinDistance1[0]), 
          "image", 370, 12, "yellow", "false");
      disp_message(hv_WindowHandle, "Dis_2 Width:  "+HTuple(hv_PinDistance1[1]), 
          "image", 400, 12, "yellow", "false");
      disp_message(hv_WindowHandle, "Dis_3 Width:  "+HTuple(hv_PinDistance1[2]), 
          "image", 430, 12, "yellow", "false");
      disp_message(hv_WindowHandle, "Dis_4 Width:  "+HTuple(hv_PinDistance2[0]), 
          "image", 460, 12, "yellow", "false");
      disp_message(hv_WindowHandle, "Dis_5 Width:  "+HTuple(hv_PinDistance2[1]), 
          "image", 490, 12, "yellow", "false");
      disp_message(hv_WindowHandle, "Dis_6 Width:  "+HTuple(hv_PinDistance2[2]), 
          "image", 520, 12, "yellow", "false");

      disp_message(hv_WindowHandle, "Average Pin Width:  "+hv_avgPinWidth, "image", 
          550, 12, "yellow", "false");
      disp_message(hv_WindowHandle, "Average Pin Distance:  "+hv_avgPinDistance, 
          "image", 580, 12, "yellow", "false");
      if (HDevWindowStack::IsOpen())
        SetDraw(HDevWindowStack::GetActive(),"margin");
      if (HDevWindowStack::IsOpen())
        SetColor(HDevWindowStack::GetActive(),"red");
      if (HDevWindowStack::IsOpen())
        DispObj(ho_RegionAffineTrans, HDevWindowStack::GetActive());
    }



    //dump_window (WindowHandle, 'tiff_rgb', 'C:\\Temp\\pins_result')
    //disp_continue_message (WindowHandle, 'black', 'true')
    //stop ()

    hv_Sigma = 1.0;
    hv_Threshold = 15;
    hv_Transition = "negative";
    hv_Select = "all";


    //**************************************调试选项********************************************************
    //**只调试上面的程序
    //FLAG_ING_YDS := 1
    //**调试全部程序
    //FLAG_ING_YDS := 0
    //**************************************保证目标被识别********************************************************

    if (0 != (hv_FLAG_ING_YDS==0))
    {

      //********************************************字符识别实现************************************************

      //**SCOP一个矩形区域******CHAR
      CropPart(ho_Image_temp, &ho_Image_temp_corp, hv_point_yds_row_crop, hv_point_yds_column_crop, 
          hv_point_yds_width_crop, hv_point_yds_height_crop);


      //*************为ocr训练做准备，程序正常运行时，请将其注释掉！！！*********************
      //dump_window (3601, 'bmp', 'C:/Users/Administrator/Desktop/HALCON工程/OCR_TRAIN_FILE/CHAR/train_demo_08')
      //stop ()
      //**Smooth by averaging
      MeanImage(ho_Image_temp_corp, &ho_Image_temp_Mean, hv_point_yds_width_crop, 
          hv_point_yds_height_crop);
      //mean_image (Image_temp, Image_temp_Mean, 31, 31)

      //*****做一个阈值自调节的动作*****

      hv_Offset_dyn_threshod = 18;
      hv_Radius_closing_circle = 3.5;

      for (hv_Index=0; hv_Index<=30; hv_Index+=0.2)
      {
        hv_Offset_dyn_threshod = 0+hv_Index;
        DynThreshold(ho_Image_temp_corp, ho_Image_temp_Mean, &ho_Region_temp_DynThresh, 
            hv_Offset_dyn_threshod, "light");
        ClosingCircle(ho_Region_temp_DynThresh, &ho_Region_temp_Closing, hv_Radius_closing_circle);
        Connection(ho_Region_temp_Closing, &ho_ConnectedRegions);
        SelectShape(ho_ConnectedRegions, &ho_SelectedRegions_char, (HTuple("height").Append("width")), 
            "and", (HTuple(45).Append(20)), (HTuple(90).Append(70)));
        SelectShape(ho_ConnectedRegions, &ho_SelectedRegions_logo, (HTuple("height").Append("width")), 
            "and", (HTuple(180).Append(160)), (HTuple(210).Append(190)));
        AreaCenter(ho_SelectedRegions_char, &hv_Area, &hv_RowCh, &hv_ColumnCh);
        if (0 != ((hv_RowCh.TupleLength())==14))
        {
          //符合要求跳出循环
          hv_Index = 30;
        }
      }
      // stop(); only in hdevelop
      //截取选择的区域
      //gen_rectangle1 (ROI_0, 323.5, 681.5, 407.5, 741.5)   * 8
      //gen_rectangle1 (ROI_0, 419.5, 903.5, 507.5, 961.5)   * 1
      //gen_rectangle1 (ROI_0, 525.5, 695.5, 587.5, 747.5)   * n
      //gen_rectangle1 (ROI_0, 317.5, 493.5, 515.5, 665.5)   * logo
      //**Characters are often dotted. Therefore, we first merge close dots
      //**that belong to the same character just before calling the operator connection
      //**Filter out characters based on facts
      //**The info (Area , Row and Column ) of region
      //MedianRow := median(RowCh)
      //select_shape (SelectedRegions1, Chars, 'row', 'and', MedianRow - 30, MedianRow + 30)
      //**Read out segmented characters
      SortRegion(ho_SelectedRegions_char, &ho_CharsSorted, "character", "true", "column");
      ShapeTrans(ho_CharsSorted, &ho_Characters, "rectangle1");
      //        do_ocr_multi_class_mlp (Characters, Image_temp, OCRHandle, Class, Confidence)
      //        do_ocr_multi_class_mlp (Characters, Image_temp, OCRHandle, Class, Confidence)
      //**Display the Image_temp
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Image_temp_corp, HDevWindowStack::GetActive());
      DilationRectangle1(ho_Characters, &ho_RegionDilation, 7, 7);
      if (HDevWindowStack::IsOpen())
        DispObj(ho_RegionDilation, HDevWindowStack::GetActive());
      AreaCenter(ho_CharsSorted, &hv_Area1, &hv_Row, &hv_Column);
      // stop(); only in hdevelop
      //*********暂时由于BUG，，去掉的内容！！！！！！！！！！！****************************************************
      //if (FLAG_ING_YDS == 0)
        //MeanRow := mean(Row)
      //endif

      //Display the results
      {
      HTuple end_val421 = (hv_Class.TupleLength())-1;
      HTuple step_val421 = 1;
      for (hv_IndexL=0; hv_IndexL.Continue(end_val421, step_val421); hv_IndexL += step_val421)
      {
        disp_message(hv_WindowHandle, HTuple(hv_Class[hv_IndexL]), "image", hv_point_yds_row+50, 
            450+(hv_IndexL*40), "black", "true");
      }
      }
      //stop ()

      //********************************************LOGO识别实现************************************************

      //**SCOP一个矩形区域******LOGO
      CropPart(ho_Image_temp, &ho_Image_temp_logo, hv_point_yds_row_logo, hv_point_yds_column_logo, 
          hv_point_yds_width_logo, hv_point_yds_height_logo);
      MeanImage(ho_Image_temp_logo, &ho_Image_temp_Mean, hv_point_yds_width_logo, 
          hv_point_yds_height_logo);
      //mean_image (Image_temp, Image_temp_Mean, 31, 31)

      //****局部阈值的选择*******
      DynThreshold(ho_Image_temp_logo, ho_Image_temp_Mean, &ho_Region_temp_DynThresh, 
          5, "light");

      ClosingCircle(ho_Region_temp_DynThresh, &ho_Region_temp_Closing, 3.5);
      Connection(ho_Region_temp_Closing, &ho_ConnectedRegions);
      //stop ()
      //**Filter out characters based on facts
      SelectShape(ho_ConnectedRegions, &ho_SelectedRegions_logo, (HTuple("height").Append("width")), 
          "and", (HTuple(180).Append(160)), (HTuple(210).Append(190)));

      //**The info (Area , Row and Column ) of region
      AreaCenter(ho_SelectedRegions_logo, &hv_Area, &hv_RowCh, &hv_ColumnCh);
      //MedianRow := median(RowCh)
      //select_shape (SelectedRegions1, Chars, 'row', 'and', MedianRow - 30, MedianRow + 30)

      //**Read out segmented characters
      SortRegion(ho_SelectedRegions_logo, &ho_CharsSorted, "character", "true", "column");
      ShapeTrans(ho_CharsSorted, &ho_Characters, "rectangle1");
      //        do_ocr_multi_class_mlp (Characters, Image_temp, OCRHandle, Class, Confidence)
      //        do_ocr_multi_class_mlp (Characters, Image_temp, OCRHandle, Class, Confidence)

      //**Display the Image_temp
      if (HDevWindowStack::IsOpen())
        DispObj(ho_SelectedRegions_logo, HDevWindowStack::GetActive());
      DilationRectangle1(ho_Characters, &ho_RegionDilation, 7, 7);
      if (HDevWindowStack::IsOpen())
        DispObj(ho_RegionDilation, HDevWindowStack::GetActive());
      AreaCenter(ho_CharsSorted, &hv_Area1, &hv_Row, &hv_Column);
      //MeanRow := mean(Row)

      //Display the results
      {
      HTuple end_val461 = (hv_Class.TupleLength())-1;
      HTuple step_val461 = 1;
      for (hv_IndexL=0; hv_IndexL.Continue(end_val461, step_val461); hv_IndexL += step_val461)
      {
        disp_message(hv_WindowHandle, HTuple(hv_Class[hv_IndexL]), "image", hv_point_yds_row+50, 
            450+(hv_IndexL*40), "black", "true");
      }
      }
      //stop ()
      //********************************备用方案*************************************************************************

      //*measure INIT方案
      //measure_pairs (Image, MeasureHandle1, Sigma, Threshold, Transition, Select, RowEdgeFirst, ColumnEdgeFirst, AmplitudeFirst, RowEdgeSecond, ColumnEdgeSecond, AmplitudeSecond, IntraDistance, InterDistance)
      //measure_pairs (Image, MeasureHandle2, Sigma, Threshold, Transition, Select, RowEdgeFirst, ColumnEdgeFirst, AmplitudeFirst, RowEdgeSecond, ColumnEdgeSecond, AmplitudeSecond, IntraDistance, InterDistance)
      //dev_display_measure_object (point_yds_row1, point_yds_column1, point_yds_phi1, point_yds_Length1, point_yds_Length2)
      //dev_display_measure_object (point_yds_row2, point_yds_column2, point_yds_phi2, point_yds_Length1, point_yds_Length2)


      //
      //Visualize the results
      //gen_rectangle2 (Rectangle, point_yds_row1, point_yds_column1, point_yds_phi1, point_yds_Length1, Length2)


      //FUZZY
      //create_funct_1d_pairs ([0.0,0.3], [1.0,0.0], FuzzyAbsSizeDiffFunction)
      //set_fuzzy_measure_norm_pair (MeasureHandle1, 15.0, 'size_abs_diff', FuzzyAbsSizeDiffFunction)
      //set_fuzzy_measure_norm_pair (MeasureHandle2, 15.0, 'size_abs_diff', FuzzyAbsSizeDiffFunction)
      //fuzzy_measure_pairs (ImageReduced, MeasureHandle1, 1, 30, 0.5, 'positive', RowEdgeFirst1, ColumnEdgeFirst1, AmplitudeFirst1, RowEdgeSecond1, ColumnEdgeSecond1, AmplitudeSecond1, RowEdgeMiddle1, ColumnEdgeMiddle1, FuzzyScore1, IntraDistance1, InterDistance1)
      //fuzzy_measure_pairs (ImageReduced, MeasureHandle2, 1, 30, 0.5, 'positive', RowEdgeFirst2, ColumnEdgeFirst2, AmplitudeFirst2, RowEdgeSecond2, ColumnEdgeSecond2, AmplitudeSecond2, RowEdgeMiddle2, ColumnEdgeMiddle2, FuzzyScore2, IntraDistance2, InterDistance2)
      //dev_display_measure_object (point_yds_row1, point_yds_column1, point_yds_phi1, point_yds_Length1, point_yds_Length2)
      //dev_display_measure_object (point_yds_row2, point_yds_column2, point_yds_phi2, point_yds_Length1, point_yds_Length2)

      //**********************************关闭操作*************************************************************************

      CloseMeasure(hv_MeasureHandle1);
      CloseMeasure(hv_MeasureHandle2);
      CloseMeasure(hv_MeasureHandle3);

      //region_to_bin (RegionAffineTrans, Image, 0, 0, Width, Height)
      //stop ()
    }

  }

  //*********************************关闭相机的句柄*************************************************************************

  CloseFramegrabber(hv_AcqHandle_of_camera);

  //**Clear an SVM-based OCR classifier
  //**and clear the classifier from memory
  //clear_ocr_class_svm (OCRHandle)
  //clear_ocr_class_svm (OCRHandleReduced)

  //**程序结束***

  //***************************临时代码区********************************************************

  //****创建训练文件(.trf)
  get_tmp_dir(&hv_TmpDir);
  hv_TrainFile = hv_TmpDir+"/letters.trf";
  hv_TrainFileBig = hv_TmpDir+"/letters_big.trf";

  if (HDevWindowStack::IsOpen())
    ClearWindow(HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    SetPart(HDevWindowStack::GetActive(),0, 0, 499, 499);
  disp_message(hv_WindowHandle, "Creating initial samples... ", "window", 12, 12, 
      "green", "false");
  gen_initial_trainfile(hv_TrainFile);







}


#ifndef NO_EXPORT_APP_MAIN

#ifdef __APPLE__
// On OS X systems, we must have a CFRunLoop running on the main thread in
// order for the HALCON graphics operators to work correctly, and run the
// action function in a separate thread. A CFRunLoopTimer is used to make sure
// the action function is not called before the CFRunLoop is running.
HTuple      gStartMutex;
H_pthread_t gActionThread;

static void timer_callback(CFRunLoopTimerRef timer, void *info)
{
  UnlockMutex(gStartMutex);
}

static Herror apple_action(void **parameters)
{
  LockMutex(gStartMutex);
  action();
  CFRunLoopStop(CFRunLoopGetMain());
  return H_MSG_OK;
}

static int apple_main(int argc, char *argv[])
{
  Herror                error;
  CFRunLoopTimerRef     Timer;
  CFRunLoopTimerContext TimerContext = { 0, 0, 0, 0, 0 };

  CreateMutex("type","sleep",&gStartMutex);
  LockMutex(gStartMutex);

  error = HpThreadHandleAlloc(&gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleAlloc failed: %d\n", error);
    exit(1);
  }

  error = HpThreadCreate(gActionThread,0,apple_action);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadCreate failed: %d\n", error);
    exit(1);
  }

  Timer = CFRunLoopTimerCreate(kCFAllocatorDefault,
                               CFAbsoluteTimeGetCurrent(),0,0,0,
                               timer_callback,&TimerContext);
  if (!Timer)
  {
    fprintf(stderr,"CFRunLoopTimerCreate failed\n");
    exit(1);
  }
  CFRunLoopAddTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);
  CFRunLoopRun();
  CFRunLoopRemoveTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);
  CFRelease(Timer);

  error = HpThreadHandleFree(gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleFree failed: %d\n", error);
    exit(1);
  }

  ClearMutex(gStartMutex);
  return 0;
}
#endif

int main(int argc, char *argv[])
{
  // Default settings used in HDevelop (can be omitted) 
  int ret=0;
  SetSystem("width", 512);
  SetSystem("height", 512);

#if defined(_WIN32)
  SetSystem("use_window_thread", "true");
#elif defined(__linux__)
  XInitThreads();
#endif

#ifndef __APPLE__
  action();
#else
  ret = apple_main(argc,argv);
#endif
  return ret;
}

#endif


#endif


